/* $Revision: 1.3 $ */
// Automatically generated by MATLAB Project Wizard version 1.0

//
// This is the gateway routine for a MATLAB Math/Graphics Library-based
// C MATLAB MEX File.

#include "mex.h"

double** CalculaDistanciaRedeRaioTextura(int **lista_nos, int N_nos, int raio, int N_vizinhos, int *mask, int tam_mask);
int* CriaMascara(int raio, int tam_mask, int nro_lin);

int CalculaDistanciaNos(int y1, int x1, int c1, int y2, int x2, int c2);
int Nro_Vizinhos(int raio);
int DistanciaRaio2(int y1, int x1, int y2, int x2);

void mexFunction(
	int nlhs,              // Number of left hand side (output) arguments
	mxArray *plhs[],       // Array of left hand side arguments
	int nrhs,              // Number of right hand side (input) arguments
	const mxArray *prhs[]  // Array of right hand side arguments
)
{
	
	double *pr, *limiar, **dist, *matriz_grau;
	int **lista_nos, *mask;
	int cont, nro_lin, nro_col, nro_limiar, raio, N_vizinhos, N_nos;
	int lin, col, li, grau, tam_mask;

   /* check number of parameters */
   if (nrhs != 3) {
      mexErrMsgTxt("CN_GrauRedeRaioTextura requires three input argument.");
   } else if (nlhs != 1) {
      mexErrMsgTxt("CN_GrauRedeRaioTextura requires one output arguments.");
   }

   nro_lin = mxGetM(prhs[0]);    /* nro linhas da imagem */
   nro_col = mxGetN(prhs[0]);    /* nro colunas da imagem */      
   pr = mxGetPr(prhs[0]);

   nro_limiar = mxGetNumberOfElements(prhs[1]); //tamanho do vetor de limiares...   
   limiar = mxGetPr(prhs[1]);//set os ponteiros dos limiares...

   raio = (int) mxGetScalar(prhs[2]); //raio utilizado...
   N_nos = nro_lin * nro_col;   
   N_vizinhos = Nro_Vizinhos(raio);
   tam_mask = (int) N_vizinhos / 2;
   mask = CriaMascara(raio, tam_mask, nro_lin);

   //aloca espaço para a matriz com os nos...
   lista_nos = (int **) malloc (N_nos * sizeof(int *));
   for (cont = 0; cont < N_nos; cont++){
	   lista_nos[cont] = (int *) malloc (3 * sizeof(int));
   }

   //copia as informações da imagem para a lista de nos...
   cont = -1;
   for (col = 0; col < nro_col; col++){
	   for (lin = 0; lin < nro_lin; lin++){
		   cont++;
		   lista_nos[cont][0] = col;
		   lista_nos[cont][1] = lin;
		   lista_nos[cont][2] = (int) pr[cont];
	   }
   }


   dist = CalculaDistanciaRedeRaioTextura(lista_nos, N_nos, raio, N_vizinhos, mask, tam_mask);
   //aloca espaço para a variavel de saida...
   plhs[0] = mxCreateDoubleMatrix(nro_limiar,N_nos,mxREAL);   
   matriz_grau = (double *) mxGetPr(plhs[0]);

   cont = -1;
   for (lin = 0; lin < N_nos; lin++){//percorre os Nos de dist
	   for (li = 0; li < nro_limiar; li++){//percorre os limiares de matriz_limiar...
		   cont++;
		   grau = 0;		   

		   for (col = 0; col < N_vizinhos; col++){//percorre a distancia dos vizinhos...
			   if (dist[lin][col] != -1){
				   if (dist[lin][col] < limiar[li]){
					   grau++;					   
				   }
			   }
		   }
		   
		   matriz_grau[cont] = grau;
	   }	   
   }    

   //limpar as variaveis...
   for (lin = 0; lin < N_nos; lin++){
	   free(dist[lin]);
	   free(lista_nos[lin]);
   }
   free(dist);
   free(lista_nos);	   
   dist = NULL;
   lista_nos = NULL;

}

int DistanciaRaio2(int y1, int x1, int y2, int x2){
	double y, x;
	y = y1 - y2;
	x = x1 - x2;
	
	return (int) (y*y + x*x);
}

int Nro_Vizinhos(int raio)
{
	int y, x, total, c;
	int raio2 = raio * raio;

	c = raio;
	total = 0;

	for (y = 0; y < (2 * raio + 1); y++){
		for (x = 0; x < (2 * raio + 1); x++){
			if (DistanciaRaio2(y,x,c,c) <= raio2){
				total++;
			}
		}
	}
	
	total--;
	return total;
}

int CalculaDistanciaNos(int y1, int x1, int c1, int y2, int x2, int c2){
	int y, x, c;
	y = y1 - y2;
	x = x1 - x2;
	c = c1 - c2;

	return (int) (y*y + x*x +c*c);	
}

double** CalculaDistanciaRedeRaioTextura(int **lista_nos, int N_nos, int raio, int N_vizinhos, int *mask, int tam_mask){	

	int y, x, p;
	int lin, col, raio2;
	double d, dist;
	double **distancias;
	int *vizinho_atual;	
	//int max_dist = (int) 255 * 255 + raio * raio;	
	int max_dist = (int) 2 * raio * raio;

	//cria lista dos vizinhos...
	vizinho_atual = (int*) malloc(N_nos * sizeof(int));

	//cria a matrix de distancias e inicia com (-1)...
	distancias = (double**) malloc(N_nos * sizeof(double *));
	for (lin = 0; lin < N_nos; lin++){
		distancias[lin] = (double*) malloc(N_vizinhos * sizeof(double));

		for (col = 0; col < N_vizinhos; col++){
			distancias[lin][col] = -1;
		}

		vizinho_atual[lin] = -1;//inicia proxima coluna com -1...
	}


	raio2 = (int) raio * raio;
	
	for (y = 0; y < N_nos; y++){		

		for (x = 0; x < tam_mask; x++){			
			p = (int) y + mask[x];

			if ((p >= 0) && (p < N_nos)){
				dist = DistanciaRaio2(lista_nos[y][0],lista_nos[y][1],lista_nos[p][0],lista_nos[p][1]);
				
				if(dist <= raio2){
					//a distancias entre os dois vertices respeita o raio...
					//p = (r^2 + (r^2 *x/255))./(r^2 + r^2);
					
					//d = lista_nos[y][2] - lista_nos[p][2];
					//dist = dist + (d * d);
					d = lista_nos[y][2] - lista_nos[p][2];
					d = (float) (raio2 * d / 255.0);
					dist = dist + d;

					vizinho_atual[y]++;
					vizinho_atual[p]++;
					
					distancias[p][vizinho_atual[p]] = dist / max_dist;
					distancias[y][vizinho_atual[y]] = dist / max_dist;				
				}
			}
		}
	}

	return distancias;
}

int* CriaMascara(int raio, int tam_mask, int nro_lin){
	int* mask;
	int y,x, raio2, cont, dist;

	raio2 = (int) raio * raio;
	cont = -1;

	mask = (int*) malloc(tam_mask * sizeof(int));
	for (y = 0; y < raio + 1; y++){
		for (x = 0; x < 2 * raio + 1; x++){
			dist = DistanciaRaio2(y,x,0,raio);
			if ((dist > 0) && (dist <= raio2)){
				if ((y == 0) && (x - raio < 0)){
					continue;
				}
				cont++;
				mask[cont] = (x - raio) * nro_lin + y;
			}
		}
	}

	return mask;
}

